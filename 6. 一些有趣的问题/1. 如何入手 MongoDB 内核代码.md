# 1. 导语
本文结合自己和周围同事学习 MongoDB 的经历，总结一些学习方法，供参考。

# 2. 一些学习经验
## 2.1 建立预期，做好长期投入的准备
MongoDB 发展至今，已经是一个非常庞大复杂的数据库。如果想要入门并熟悉它，需要有长期投入的思想准备：    
- **文档多**。MongoDB 官网提供了丰富的文档和视频教程方便上手使用。另外，在 github 上提供了 specifications 和 wiki，如果想深入了解 MongoDB 的实现，这将是非常重要的参考资料。    
- **代码多，迭代快**。内核代码已经超过百万行，如果再算上各种编程语言的 driver ，以及 mongodump/mongorestore 这些外围工具，代码量非常大。另外，MongoDB 的迭代也非常迅速，以 3.0 到 5.0 期间的版本为例，基本上每隔 1 年就会推出至少 1 个重磅特性。而且随着 C++ 本身的发展，MongoDB 内核代码也在飞速进化。    
- **特性多**。如果翻开 10 年前的知乎和博客网站，大家对 MongoDB 的印象只是对 JSON 支持好一点的分布式 KV 系统。但是随着近些年的发展，MongoDB 俨然已经成为了数据库的百科全书。相信大家在学习 《DDIA》、《MySQL 45 讲》等各类数据库文献时，都能从 MongoDB 中找到对照。    

所以，如果希望深入了解 MongoDB，需要先建立好自己的心理预期。不要抱着几周速成的想法，要做好长达几年持续学习的准备。

## 2.2 明确目标，指定学习计划
这里先附上 MongoDB 作者在知乎上的高赞回答，可以作为重要参考：https://www.zhihu.com/question/19882468/answer/18329680    

一般来说，比较好的学习路线都是循序渐进的，先熟悉文档并自己搭建并使用 MongoDB，然后再有针对性的学习 MongoDB 代码。    
个人认为，每个人学习 MongoDB 的目的并非完全相同，因此希望了解的东西也可能是不一样的。所以，在开始学习之前，建议先根据自身的诉求和兴趣，明确学习目标和重点，然后有的放矢。    
这里抛砖引玉列举几点：    
- MongoDB 使用者。可能会讲重点放在熟悉官方文档，并了解 driver 和工具的使用和实现。    
- 存储开发者。希望从 MongoDB 中找寻一些设计灵感，并借鉴一些功能实现方式。可能会将重点放在文档模型、复制集和分片集群的实现。    
- 数据库爱好者。可能会将重点放在执行计划、分布式事务等功能的实现。    
- C++ 后台开发者。希望从 MongoDB 代码中学习一些优秀的编码实现。可能会将重点放在线程模型、连接模型、函数式编程、设计模式等方面。    

## 2.3 准备好环境，在实践中学习
工欲善其事，必先利其器。确定好了学习计划之后，就可以开始上手代码了。    

由于我日常工作的开发平台都是 Linux(CentOS)，因此习惯使用 VSCode + SSH-Remote 插件进行远程开发：VSCode 安装在本地的 windows 或者 mac 上，代码的编译、跳转、调试等通过远程插件来操控。再结合VSCode 中的 c++、clangd、git 、gdb等插件，基本就能满足绝大多数需求。    
不同版本的代码，在实现逻辑、代码风格甚至文件路径的组织都存在差别，因此最好是确定一个 release 版本，然后持续研究。可以是自己目前线上使用的版本，或者是当前最新的 release 版本。    

工具和代码都准备完之后，接下来就是看代码做测试了。那么从何看起呢？    
1. 理清代码的基本脉络。首先要理清楚代码的大致架构，比如 mongos 和 mongod 的main 函数入口在哪里，启动流程是怎样的，怎么去 listen 网络请求，又是怎么调用命令的 run 方法。每个目录存放的文件大致对应了哪些功能。要理清这些脉络，可以借助代码中的 sconscript 编译脚本和 gdb 工具。    
2. 分模块，带着问题去学习。不要漫无目的的欣赏代码，这样很容易走神并迷失方向，更好的方式是带着自己的疑问和思路去“审视”和“确认”代码。我的学习步骤一般是：整理一些小问题 => 自己设想解决方法 => 代码阅读+调试验证 => 复盘 MongoDB 这样实现的原因 => 其他数据库如何做的，进行横向对比 => 总结归纳。    

# 3. 准备工具
## 3.1 准备开发机
推荐使用 WSL、Linux云服务器或者 Mac 进行开发。


## 3.2 VSCode 配置
在本地安装好 VSCode 以及 Remote-SSH 插件，然后连接到远程开发机。

然后 git clone 内核代码 docs/building.md 中的指引配置好 gcc 和 python 环境。

**安装 clangd 插件**   
1. 在 VSCode 上远程安装 Clangd 插件
2. 在远程开发机上安装 Clangd 服务。可以根据 VSCode 的提示进行安装，也可以自行下载安装。下载地址：https://github.com/clangd/clangd/releases/download/16.0.2/clangd-linux-16.0.2.zip

**配置 clangd 插件**    

在 VSCode 的 settings 中配置 clangd 参数：     
<p align="center">
  <img src="https://github.com/pengzhenyi2015/MongoDB-Kernel-Study/assets/16788801/70ce7a6f-45fa-47e9-b09e-58d5d3af7ff0" width=650>
</p>

相关参数为：    
```
--background-index
-j=4
--clang-tidy
--all-scopes-completion
--completion-style=detailed
--function-arg-placeholders
--header-insertion=iwyu
```
具体有那些参数，以及各自的含义，可以执行 clangd --help 进行查看。 
## 3.3 调试    
**代码跳转**   

编译 compile_commands.json（以 4.0 版本为例）：   
```
python buildscripts/scons.py compiledb MONGO_VERSION="4.0.3" -j4 CC=/home/pengzhenyi/opt/gcc5.4/bin/gcc CXX=/home/pengzhenyi/opt/gcc5.4/bin/g++
```
编译完成之后，会在当前的工作目录下生成  compile_commands.json 文件。    
VSCode 的 clangd 插件会自动根据这个文件，给代码创建索引：    
<p align="center">
  <img src="https://github.com/pengzhenyi2015/MongoDB-Kernel-Study/assets/16788801/db0c943e-12f5-4bbd-8ddf-8c493009bd6e" width=500>
</p>

索引创建完成之后，就可以非常方便的分析代码了。    

>注： 截止写这篇文章时，VSCode 的默认 c++ 插件也能支持 compile.json 的跳转以及 auto 类型推导等高级特性。但还是能感受到跳转速度和 clangd 插件还是有明显差距，个人推测可能和 clangd 会自动创建索引并进行缓存有关系。

**调试跟踪**    
使用 VSCode + SSH Remote 进行调试。    
编译一个 debug 版本的 mongod（**编译的时候，指定 --dbg=on**）：    
```
python buildscripts/scons.py mongod MONGO_VERSION="4.0.3" --ssl=on -j4 --dbg=on CC=/home/pengzhenyi/opt/gcc5.4/bin/gcc CXX=/home/pengzhenyi/opt/gcc5.4/bin/g++
```
根据自己的机器环境配置VSCode 的 lauch.json 配置，举例如下：    
```
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        
        {
            "name": "mongod",
            "type": "cppdbg",
            //"request": "launch",
            "request": "attach",
            "program": "${workspaceFolder}/build/debug/mongo/mongod",
            //"args": ["-f", "/data/zhenyipeng/mymongo/conf/mongod.conf"],
            //"stopAtEntry": false,
            //"cwd": "${workspaceFolder}",
            //"environment": [],
            //"externalConsole": false,
            "processId": "${command:pickProcess}",
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            //"preLaunchTask": "C/C++: g++ build active file",
            "miDebuggerPath": "/usr/bin/gdb"
        }
    ]
}
```
**需要说明的是，启动debug 调试时，需要打开 "C/C++" 插件，关闭 clangd 插件，否则可能会有冲突。**

配置完成后，就能使用 VSCode 的 debug 功能 attach 到远程开发机上的 MongoDB 进程，然后打断点调试。

# 4. 一些常用的开发技巧
下面介绍常用的开发技巧，方便大家根据 MongoDB 代码快速实现一些简单的功能。

不同内核版本之间可能存在差异，**如果未特别注明，都是基于 4.2 版本。**

## 4.1 日志打印
**4.2 及以下版本**    

1.在 cpp 文件头部定义日志类型。

```
#define MONGO_LOG_DEFAULT_COMPONENT ::mongo::logger::LogComponent::kCommand
```
除了 kCommand，还有 kQuery, kSharding等，具体参考 log_component.h 中的定义。       

2.包含 log.h 头文件。
```
#include "mongo/util/log.h"
```

3.在代码中打印日志。
```
常规日志：
log() << "test log";
LOG(0) << "test log"; // 数字越大，越不容易打印，数字最高是 7. LOG(0) 和 log() 的效果一样

错误日志：
error() << "test error log";
warning() << "test warning log";
```
根据官方建议，错误日志最好使用 error() 和 warning().   

**4.4 及以上版本**    

4.4 及以上版本，将日志改成了对机器更友好的 json 格式。使用方式参考文档中的例子 ：https://github.com/mongodb/mongo/blob/master/docs/logging.md    
需要特别注意的是，每处打印日志的代码都要分配一个全局唯一的 log id。    

## 4.2 库表访问
### 4.2.1 本地访问
如果是 mongod 或者 config server 上，可能存在访问本地库表的需求。步骤如下：    
1.包含 dbdirectclient.h 头文件。    
```
#include "mongo/db/dbdirectclient.h"
```
2.生成 DBDirectClient，然后进行本地库表访问。   
```
auto opCtx = cc().makeOperationContext(); // 如果已有 opCtx, 则可以忽略这一步
DBDirectClient client(opCtx.get()); // 生成 DBDirectClient
BSONObj res = client.findOne("库名.表名", BSON("_id" << "过滤条件"));
```
DBDirectClient 继承自 DBClientBase, 里面定义的接口除了 fineOne 之外，还有 runCommand 等接口，可以满足常见的需求。    
具体可以参考 dbclientinterface.h 中对于 DBClientBase 的定义。    

### 4.2.2 远程访问
如果是 mongos 节点，可能需要远程读写 config server 或者 mongod 库表的需求。步骤如下：    
1.包含 grid.h 头文件。
```
#include "mongo/s/grid.h"
```
2.生成 ShardingCatalogClient 并执行命令。
```
auto opCtx = cc().makeOperationContext();  // 如果已有 opCtx 则忽略这一步
auto catalogClient = Grid::get(opCtx.get())->catalogClient();  // 生成client
BSONObjBuilder result;
const bool ok = catalogClient->runUserManagementReadCommand(opCtx.get(), "库名", BSON("find" << "表名" << "filter" << BSON("_id" << "过滤条件")), &result);
```
除了 runUserManagementReadCommand 和 runUserManagementWriteCommand 之外，还有 getAllShards 等常用方法，具体可以参考 sharding_catalog_client.h 中对于 ShardingCatalogClient 的定义。    

## 4.3 后台任务
如果希望启动一个后台任务，首先想到的可能是 pthread_create 创建一个后台线程。在 MongoDB 内核中，定义了一个基类 BackgroundJob，里面已经封装好了启动后台线程的相关方法，开发者只需要继承这个基类，并 override 里面的 name() 和 run() 方法即可。    
原生 MongoDB 代码中的 TTLMonitor，Checkpoint 等后台任务都是使用的这种方式。    

使用步骤为：    
1.包含头文件 background.h。
```
#include "mongo/util/background.h"
```
2.定义一个后台任务类，并继承自 BackgroundJob。    
```
class MyJob : public BackgroundJob {
public:
    MyJob();
    ~MyJob(){}

protected:
    virtual std::string name() const;
    virtual void run();
    
private:
    xxx;
};
```
3.实现 name() 方法，返回自己的名字即可。    
```
std::string MyJob::name() const {
    return "MyJob";
}
```
4.实现 run() 方法，定义好需要后台执行的任务。    
```
void MyJob::run() {
    Client::initThread("MyJob");
    
    while(!globalInShutdownDeprecated()) {
       xxx;  // 执行后台任务
    }
}
```
5.在代码主流程中实例化后台任务对象，并启动后台任务。
```
myJob = new MyJob();
myJob->go();
```

## 4.4 新增配置参数
### 4.4.1 SERVER_PARAMETER 方式
原生代码中广泛使用的配置方式，推荐使用这种方式新增配置。   
好处是：可以通过 getParameter 和 setParameter 命令进行动态配置变更和查询，也能持久化到配置文件中。   

使用步骤如下：    
1.包含 server_parameters.h 头文件。    
```
#include "mongo/db/server_parameters.h"
```
2.使用宏来定义新增的 parameter。    
```
// 在宏中指定 参数名，类型和默认值
MONGO_EXPORT_SERVER_PARAMETER(skipCorruptDocumentsWhenCloning, bool, false);
```
原生代码中提供了 3 种类型的宏定义用于不同的用途：   
- MONGO_EXPORT_SERVER_PARAMETER,  参数可以在启动时和运行时指定。
- MONGO_EXPORT_STARTUP_SERVER_PARAMETER，参数只能在启动时指定。
- MONGO_EXPORT_RUNTIME_SERVER_PARAMETER， 参数只能在运行时指定。

3.代码中使用参数。
```
if (skipCorruptDocumentsWhenCloning.load()) {
  xxx;
}
```
4.系统管理员可以通过 getParameter 和 setParameter 进行参数设置和检查。   

### 4.4.2 在配置文件中新增自定义配置
在配置文件中新增一行配置，可能是很多开发人员首先会想到的。比如原生代码中，dbpath 和 log 路径等都是采用这种方法。    
对于一些模板化的配置，推荐使用这种方式。但是如果参数需要在运行过程中经常调整，则不推荐采用这种方式。    

下面以 mongos 配置文件中新增一个配置，来展示如何使用这种方式。    

1.在 server_options_server_helper.cpp 中的 addGeneralServerOptions 方法中新增一个参数。    
```
options
    ->addOptionChaining(
            "myNewSetting", "myNewSetting", moe::String, "config file settings test")
    .setSources(moe::SourceYAMLConfig)
    .setDefault(moe::Value("set-default"));
```
上述代码新增了一行新配置，名称是 myNewSetting。

2.在 mongos_options.h 中 MongosGlobalParams 结构的定义中增加 myNewSetting 参数。
```
struct MongosGlobalParams {
    // The config server connection string
    ConnectionString configdbs;
    // 新增参数 
    std::string myNewSetting
};
```
3.在 mongos_options.cpp 的 storeMongosOptions 方法中增加参数解析。    
```
if (params.count("myNewSetting")) {
    mongosGlobalParams.myNewSetting = params["myNewSetting"].as<std::string>();
}
```
4.在其他代码逻辑中使用新增参数。
```
if (!mongosGlobalParams.myNewSetting.empty()) {
    xxxx;
}
```
### 4.4.3 使用内置库表存储配置信息
值得注意的是，MongoDB 作为一个数据库，本身就非常适合存储配置信息。使用内置库表存储配置信息的方式在原生 MongoDB 中也非常普遍，比如 admin.system.users 表用来存储用户信息，config.settings 表用来存储均衡服务的配置信息，config.chunks 表用来存储分片表的路由信息等。    
开发者可以根据自己的需要指定一个表存储自己的配置，然后根据前文介绍的方法，启动一个后台任务定期检查表中的内容是否改变，并及时同步。    

总体来说，3种方式各有优劣，开发者可以根据自身实际情况进行选择。    

|配置方式|优点|缺点|适合场景|
|:--|:--|:--|:--|
|SERVER_PARAMETER方式|灵活，支持动态修改，支持持久化|每个节点需要单独配置。如果新增节点，会有配置不一致的风险| cursor 超时，tcmalloc 配置等|
|配置文件|持久化，便于模板化部署|不支持动态修改，需要考虑多个节点的配置一致性|dbpath, log 路径等|
|内置库表|灵活，持久化，新增节点自动同步，多个节点的配置一致|需要较多的代码开发逻辑|balancer，路由，用户信息等需要动态修改并全局同步的配置|

## 4.5 BSON 操作 
### 4.5.1 BSON 解析   

### 4.5.2 BSON 组装

### 4.5.3 BSON 修改

## 4.6 新增命令

## 4.7 客户端和权限认证相关
### 4.7.1 权限认证信息

### 4.7.2 客户端信息

## 4.8 测试相关

## 4.9 编译和第3方库的使用    
下面以 boost 为例，说明如何使用第 3 方库，如何修改 SConscript 编译脚本，以及如何包含头文件。    
### 4.9.1 头文件引用

### 4.9.2 引用第 3 方库

### 4.9.3 boost 读写锁

## 4.10 WiredTiger 日志调试
### 4.10.1 增加日志

### 4.10.2 打印日志

## 4.11 一些关键数据结构


# 5. 参考文档
1. https://github.com/mongodb/mongo/wiki/Write-Tests-For-Server-Code
2. https://github.com/mongodb/mongo/wiki/Test-The-Mongodb-Server
3. https://github.com/mongodb/mongo/wiki/Write-Benchmark-Tests
4. https://github.com/brianfrankcooper/YCSB/tree/master/mongodb
5. https://source.wiredtiger.com/3.2.1/group__wt.html#gacbe8d118f978f5bfc8ccb4c77c9e8813
6. https://github.com/mongodb/mongo/blob/master/docs/logging.md
7. https://www.zhihu.com/question/19882468/answer/18329680
8. https://learn.mongodb.com/
