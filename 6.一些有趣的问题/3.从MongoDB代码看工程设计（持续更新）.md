# 1. 设计模式

## 1.1 装饰器模式

### 什么是装饰器
在软件设计中，装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。     
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。这种模式通常用来为现有对象添加装饰，但是它不能用于已将对象作为参数传递给构造函数的情形。    

比如在 MongoDB 中定义了 Client 类描述客户端信息，包括 TCP 会话（源端地址，目标端地址）、是否为内部连接，连接 id 等。    
但是除了上述基本信息之外，Client 的认证信息（AuthenticationSession）、权限信息（AuthorizationSession）等也是和自身一一对应的。

常见的解决方法有：    
1. 直接在 Client 中添加认证信息、权限信息等字段，但是这样会破坏类的封装性。    
2. 使用继承的方式，在 Client 基础上添加认证信息、权限信息等类。比如在 Client 基础上添加 AuthenticationClient 等类。 但是如果其他基础类也是用了 AuthenticationSession 信息，也要定义自己的派生类，这样会带来大量的代码冗余。   

装饰器模式可以解决上述问题，通过装饰器模式，可以将认证信息、权限信息等独立出来，然后通过 Client 类的装饰器字段指向认证信息、权限信息等对象，这样既不会破坏类的封装性，代码上也会非常简洁。     

### MongoDB 中的装饰器    
MongoDB 内核中的 Client、OperationContext、ServiceContext 等基础类都使用了装饰器模式。       

#### 核心思路
以基础类为 D，需要给其装饰 T1 和 T2 为例。**核心思路就是给每个 D 对象分配一段内存区域存放 T1 和 T2，并且负责管理 T1 和 T2 的生命周期。**   

主要涉及到以下数据结构：    
- **Decorable**：定义在 [util/decorable.h](https://github.com/mongodb/mongo/blob/r4.2.25/src/mongo/util/decorable.h) 文件中。在定义 D 时，需要继承 public Decorable<D>，表示 D 是一个可装饰的类。代码的其他位置就可以使用 D::declareDecoration<T1> 和 D::declareDecoration<T2> 声明 T1 和 T2 是 D 的 挂件。每次调用 declareDecoration 函数会返回一个 Decoration 对象，这个对象中会记录 T1/T2 装饰在 D 的哪个位置（可以理解为一段堆内存中的偏移），通过不同的 Decoration 对象可以快速找到具体的挂件。                  
- **DecorationRegistry**：定义在 [util/decorable_registry.h](https://github.com/mongodb/mongo/blob/r4.2.25/src/mongo/util/decoration_registry.h) 文件中。当 D 通过前面的步骤声明自己为 Decorable 时，就会实例化一个 DecorationRegistry 对象（static 的），这个对象会完成装饰器模式的主要控制逻辑：比如 declareDecoration 时，会根据 T1/T2 的大小进行对齐后，统计堆 buffer 的总大小，并给 T1/T2 分配具体的位置；在 D 进行构造时，会在指定的内存位置构造 T1/T2 对象；在 D 进行析构时，会调用 T1/T2 的析构函数。      
- **DecorationContainer**：定义在 [util/decorable_container.h](https://github.com/mongodb/mongo/blob/r4.2.25/src/mongo/util/decoration_container.h) 文件中。每个 Decorable 对象都会实例化一个 DecorationContainer 对象，这个对象中会保存 D 的所有挂件。DecorationContainer 本质上是一段堆内存（std::unique_ptr<unsigned char[]>），内存长度由 DecorationRegistry 提供，每当构建 D 对象时，会根据 DecorationRegistry 提供的长度信息进行内存分配。      

#### 用法
以 [util/decorable_test.cpp](https://github.com/mongodb/mongo/blob/r4.2.25/src/mongo/util/decorable_test.cpp) 中的单元测试为例。     
```cpp
// 定义 主类/被装饰类 是可被装饰的
class MyDecorable : public Decorable<MyDecorable> {};

// 定义 装饰器类/挂件
static int numConstructedAs;   // A 被构造的总数
static int numDestructedAs;    // A 被析构的总数
class A {
public:
    A() : value(0) {
        ++numConstructedAs;
    }
    ~A() {
        ++numDestructedAs;
    }
    int value;
};

// 具体的执行逻辑
TEST(DecorableTest, DecorableType) {
    const auto dd1 = MyDecorable::declareDecoration<A>();  // 声明 A 是 MyDecorable 的装饰器，并返回 A 在堆内存上的位置
    const auto dd2 = MyDecorable::declareDecoration<A>();  // 再次声明 A 是 MyDecorable 的装饰器。并返回第 2 个 A 在堆内存上的位置
    const auto dd3 = MyDecorable::declareDecoration<int>();  // 声明 int 是 MyDecorable 的装饰器，并返回 int 在堆内存上的位置
    numConstructedAs = 0;
    numDestructedAs = 0;
    {
        MyDecorable decorable1;  // 构造 MyDecorable 对象
        ASSERT_EQ(2, numConstructedAs);  // 构造了 2 个 A (在内存中顺序排列)
        ASSERT_EQ(0, numDestructedAs);
        MyDecorable decorable2;  // 构造另一个 MyDecorable 对象
        ASSERT_EQ(4, numConstructedAs);  // 构造了 2 个 A (在 decorable2 d的内存中顺序排列)
        ASSERT_EQ(0, numDestructedAs);

        ASSERT_EQ(0, dd1(decorable1).value);  // decorable1 的 第 1 个 A 对象的 value
        ASSERT_EQ(0, dd2(decorable1).value);  // decorable1 的 第 2 个 A 对象的 value
        ASSERT_EQ(0, dd1(decorable2).value);  // decorable2 的 第 1 个 A 对象的 value
        ASSERT_EQ(0, dd2(decorable2).value);  // decorable2 的 第 2 个 A 对象的 value
        ASSERT_EQ(0, dd3(decorable2));  // decorable2 的 int 对象
        dd1(decorable1).value = 1;  // 给上述对象赋值 
        dd2(decorable1).value = 2;
        dd1(decorable2).value = 3;
        dd2(decorable2).value = 4;
        dd3(decorable2) = 5;
        ASSERT_EQ(1, dd1(decorable1).value);  // 再次确认赋值后的对象
        ASSERT_EQ(2, dd2(decorable1).value);
        ASSERT_EQ(3, dd1(decorable2).value);
        ASSERT_EQ(4, dd2(decorable2).value);
        ASSERT_EQ(5, dd3(decorable2));
    }
    ASSERT_EQ(4, numDestructedAs);  // decorable1 和 decorable2 都被析构，每个对象都析构 2 个 A
}
```

#### 构造和析构流程
整体流程如下图所示：
1. 在初始化阶段，使用 declareDecoration 函数声明装饰器，计算装饰器总内存大小，并确定每个装饰器在内存中的位置。
2. 在运行时阶段，在构造主类对象（被装饰的对象）时，会在堆上分配内存空间并在指定位置构造装饰器对象。在析构主对象时则会析构装饰器并释放内存。    

<p align="center">
  <img src="https://github.com/user-attachments/assets/ce2dd6fd-9b9f-40cb-859d-61d71855e38a" width=800>
</p>

## 1.2 单例模式


## 1.3 观察者模式


# 2. 算法和数据结构

## 2.1 WriteConflict 的运用
在前面章节中，提到了 WT 引擎采用乐观锁机制实现高并发。如果 2 个事务同时修改了同 1 条文档，由于 first-update-win 机制，只有一个事务会提交成功，另一个事务会由于 writeConflict 失败并依赖上层的重试。     

**如果利用事务的原子性，再结合 writeConflict 的冲突检测能力，就能在上层应用中实现乐观锁。**        

上述 “乐观锁” 机制在 MongoServer 层的索引中得以广泛使用，下面列举 2 个例子。

### 索引的唯一性检测
在 1.2 章节中，提到了 MongoDB 中索引的格式为： {Key: IndexKey+RecordId, Value: typeBits}, 其中 IndexKey 是索引的 key，RecordId 是文档的唯一id（一般为自增 int64）， typeBits 用于将 KeyString 格式的字符串转回原始类型。     
索引的唯一性检测需要通过 Key 的前缀来判断。    

假设我们对 "a" 字段创建了唯一索引，然后同时插入了 2 条 "a" 字段为 1 的文档：    
- 事务 1：**检测**没有前缀为 "a=1" 的索引，于是往索引中插入记录 {Key: "a=1" + record1, Values: typeBits}.
- 事务 2：**检测**没有前缀为 "a=1" 的索引，于是往索引中插入记录 {Key: "a=1" + record2, Values: typeBits}.

此时，由于 2 个事务都插入成功，导致索引中出现了重复的记录。    

MongoDB 通过构造写冲突的方式来解决上述问题，在上述流程中增加了**额外步骤**：    

- 事务 1：插入 {Key:"a=1", Value: typeBits}, 然后删除之。
- 事务 2：插入 {Key:"a=1", Value: typeBits}, 然后删除之。

通过上述处理，2 个事务出现了写冲突，只有一个事务能够插入成功。而另外一个事务失败后进入重试，然后检测到有 "a=1" 的索引前缀，并给客户端报错。

### 后台建索引的冲突检测
在 MongoDB 早期版本有 background 建索引功能（4.2 之后逐步被更优的 hybrid 模式取代）。      
在 [MongoDB 索引使用总结](https://mp.weixin.qq.com/s/g0mNt73nnFS_xyVGuAPe-g) 中提到一个后台建索引时处理冲突的 case。核心思想是主动构造写冲突，避免索引和表的数据不一致。这里不再赘述。    

## 2.2 为多 CPU 架构而生的 LRU 


## 2.3 为多 CPU 架构而生的 mutex


## 2.4 实时预估数据压缩率


# 3. 参考文档
1. https://www.runoob.com/design-pattern/decorator-pattern.html
2. https://github.com/mongodb/mongo/tree/r4.2.25
3. MongoDB 索引使用总结：https://mp.weixin.qq.com/s/g0mNt73nnFS_xyVGuAPe-g
