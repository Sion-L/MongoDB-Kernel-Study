# 1. MongoDB 内核架构
关于分布式(Sharding) 和副本集(Replication) 的内容放到后面的章节讨论。这里主要讨论单个 mongod 节点的内核架构。    
引用[官方文档](https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-1)的架构图如下：    
<img src="https://github.com/pengzhenyi2015/MongoDB-Kernel-Study/assets/16788801/814fcfb9-c3b9-415f-a44e-454d937c6abd" width=700>

如图所示，用户使用 MongoDB query language 进行数据的增删查改操作，MongoDB 服务侧生成对应的执行计划，然后调用 Document Model 提供的接口进行数据处理，并将处理后的结果返回给用户端。如果涉及到数据变更，还会将新生成的数据序列化之后存储到底层的 KV 存储引擎。      

没有一个存储引擎能完美适配所有的业务场景。当业务在选择合适的数据库时，除了数据库的稳定性、易用性、流行度、基准测试性能等方面的考虑外，还会根据自身的业务特点并结合存储引擎的特性进行分析和压测。比如使用机械硬盘存储日志类的场景，可能会优先考虑 LSMTree 类型的存储引擎；对于使用大内存、NVMe-SSD 并存在大量随机读写的场景，可能会更倾向于使用 Btree 类的存储引擎。       
为了适配更多的业务场景，很多数据库产品都支持插件式存储引擎，比如 MySQL 就支持 MyIASM、InnoDB、RocksDB 等多种存储引擎。     
MongoDB 从 3.x 版本开始，也通过插件式存储引擎的形式，支持了越来越多的存储引擎。比如官方文档中公布的存储引擎就有：      
<img src="https://github.com/pengzhenyi2015/MongoDB-Kernel-Study/assets/16788801/6741cd21-22a8-436a-9349-2a9e9303282f" width=700>     
另外，MongoDB 在 3.x 版本也支持RocksDB 引擎。对于存储日志、账单类型的业务，以及使用机械硬盘的业务场景有比较大的性能优势。
使用方式可以参考 [MongoRocks](https://github.com/mongodb-partners/mongo-rocks) 的介绍。
但是需要说明的是 RocksDB 目前还不是 MongoDB 官方支持的存储引擎。

MongoDB 为了支持插件式存储引擎，定义了一个虚基类 [KVEngine](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/kv/kg_engine.h) 规定 KV 存储引擎接入 MongoDB 的标准，具体规范了建表、建索引、获取引擎元数据等操作的接口。另外，也定义了虚基类 [RecordStore](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/record_store.h) 定义了表的操作接口，以及虚基类 [SortedDataInterface](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/sorted_data_interface.h) 定义了索引的操作接口， [SnapshotManager](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/snapshot_manager.h) 用于 snapshot 管理。      
以 WiredTiger 引擎为例，通过 [WiredTigerKVEngine](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/wiredtiger/wiredtiger_kv_engine.h) 实现存储引擎的接入接口，通过 [WiredTigerRecordStore](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.h) 和  [WiredTigerIndex](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/wiredtiger/wiredtiger_index.h) 实现了表和索引的操作接口，通过  [WiredTigerSnapshotManager](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/wiredtiger/wiredtiger_snapshot_manager.h) 实现了 snapshot 的管理机制。       
上述相关代码存放在代码目录 "src/mongo/db/storage/wiredtiger/" 中，独立于 WiredTiger 引擎的代码。可以看作是 MongoServer 和底层存储引擎之间的接口层。这个接口层实现了 MongoDB 规定的接口，并调用底层存储引擎的 API 完成具体的数据操作。   
而 Wiredtiger 引擎本身有独立的代码仓库，放在 thirdparty 目录下，和 MongoDB 代码进行联合编译。   

同理，RocksDB 引擎也是独立的代码仓库，可以通过 MongoRocks 这个接口层接入到 MongoDB 中。在 MongoRocks 中也对应的通过 RocksEngine(rocks_engine.h) 实现了存储引擎的接入接口，通过 RocksRecordStore(rocks_record_store.h) 和 RocksIndexBase(rocks_index.h) 实现了表和索引的操作接口，通过  RocksSnapshotManager(rocks_snapshot_manager.h) 实现了 snapshot 的管理操作接口。
# 2. MongoDB 如何使用 WiredTiger 存储数据

从前面的分析可以发现，KV 存储引擎是不感知 BSON 文档模型的。
在 KV 引擎中存储的数据有：
1. recordId, int64 类型，作为表在 KV 引擎中存储时的 Key;
2. BSON 文档序列化后的字符串，String 或者 byte[] 类型，作为表在 KV  引擎中存储时的 Value；
3. KeyString, String或者 byte[] 类型，作为索引在 KV 引擎中存储时的 Key;
4. (KeyString的 )typeBits， String 或者 byte[] 类型，作为索引在 KV  引擎中存储时的 Value;

MongoDB 中的表和索引，对应到 Wirediger 存储引擎中都是 'wt table'. 由于 MongoDB 中表和索引存储的数据类型有所区别，因此在定义 ‘wt table’的schema 时也会不同。  
WiredTiger 目前支持的[存储类型](https://source.wiredtiger.com/3.2.1/schema.html#schema_format_types) 有：    
<img src="https://github.com/pengzhenyi2015/MongoDB-Kernel-Study/assets/16788801/1c7e3be2-9289-4d9d-94e3-044671d357d7" width=500>       
对于 MongoDB 表来说，存储的数据是 recordId -> BSON文档，因此对应的 'wt table' schema 为 "key_format=q, value_format=u".   
对于 MongoDB 索引来说，存储的数据时 KeyString-> typeBits, 因此对应的 'wt table' schema 为 "key_format=u, value_format=u".

除了上述 Key/Value 的类型之外，在定义 'wt table' 时还可以指定 叶子节点大小、数据块对齐大小、数据块分配和压缩算法等参数。详细的配置参数和说明，可以参考 [WT 官方文档](https://source.wiredtiger.com/3.2.1/struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb)

MongoDB 在建表和建索引时具体指定的 schema 参数可以参考 [WiredTigerRecordStore::generateCreateString](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.cpp#L553) 和 [WiredTigerIndex::generateCreateString](https://github.com/mongodb/mongo/blob/r4.0.28/src/mongo/db/storage/wiredtiger/wiredtiger_index.cpp#L195)

>tips: 对于 MongoDB 用户来说，可以在连接上 MongoDB 节点之后，通过db.colltest.stats().wiredTiger.creationString命令来查看建表时的各项参数，举例如下：    
>access_pattern_hint=none,allocation_size=4KB,app_metadata=(formatVersion=1),assert=(commit_timestamp=none,read_timestamp=none),block_allocation=best,block_compressor=snappy,cache_resident=false,checksum=on,colgroups=,collator=,columns=,dictionary=0,encryption=(keyid=,name=),exclusive=false,extractor=,format=btree,huffman_key=,huffman_value=,ignore_in_memory_cache_size=false,immutable=false,internal_item_max=0,internal_key_max=0,internal_key_truncate=true,internal_page_max=4KB,key_format=q,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=32KB,leaf_value_max=64MB,log=(enabled=false),lsm=(auto_throttle=true,bloom=true,bloom_bit_count=16,bloom_config=,bloom_hash_count=8,bloom_oldest=false,chunk_count_limit=0,chunk_max=5GB,chunk_size=10MB,merge_custom=(prefix=,start_generation=0,suffix=),merge_max=15,merge_min=0),memory_page_image_max=0,memory_page_max=10m,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=false,prefix_compression_min=4,source=,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=90,type=file,value_format=u



# 3. WiredTiger 存储引擎架构简介

参考[官方文档](https://source.wiredtiger.com/develop/arch-index.html)，WiredTiger 引擎的整体架构如下：   
<img src="https://github.com/pengzhenyi2015/MongoDB-Kernel-Study/assets/16788801/1e4f2f65-bead-4471-a802-88d458b328fd" width="500">

涉及到的一些重要组件和概念包括：
- [Schema](https://source.wiredtiger.com/develop/arch-schema.html): 引擎中存储的数据格式，其中定义了 Key 和 Value 的类型。
- [Metadata](https://source.wiredtiger.com/develop/arch-metadata.html): WiredTiger 引擎的元数据，定义了有哪些表以及对应的文件，Checkpoint 信息等，使用 WiredTiger.wt 这个特殊的表进行存储。
- [Cursor](https://source.wiredtiger.com/develop/arch-cursor.html): WiredTiger 对外的数据接口都通过 Cursor 执行，Cursor 指向了表中的某个位置，Cursor 给上层提供了按 Key 检索，迭代，读写数据等操作接口。
- [Dhandle](https://source.wiredtiger.com/develop/arch-dhandle.html):描述了一个资源的句柄，通俗理解为一个 'wt table'. 一般指向一个 Btree；
- [Btree](https://source.wiredtiger.com/develop/arch-btree.html): WiredTiger 中存储表的一种格式，其中 root page 和 internal page 只存储 key 和下一层 page 的指针，leaf page 存储用户写入的 KV 数据，Btree 是一个按 key 有序的数据结构。WiredTiger 中的 Btree 节点在内存中的表现形式与磁盘上的表现形式有所区别。
- [Transaction](https://source.wiredtiger.com/develop/arch-transaction.html): 事务接口。  
- [Snapshot](https://source.wiredtiger.com/develop/arch-snapshot.html): WiredTiger 使用 snapshot 进行多版本并发控制，snapshot 定义了哪些版本的数据对事务可见，哪些版本不可见。
- [Row/Column Store](https://source.wiredtiger.com/develop/arch-row-column.html): MongoDB 使用 WiredTiger 引擎的 row store 模式。
- [Cache](https://source.wiredtiger.com/develop/arch-cache.html): WiredTiger 引擎使用内存来缓存最近访问和修改的 page，当 cache 使用率超过设定的阈值时，会通过 eviction 和 checkpoint 操作进行清理。
- [Eviction](https://source.wiredtiger.com/develop/arch-eviction.html): 当 Cache 使用率或者脏页比率达到设定的阈值后，会通过 eviction 流程选择合适的 page 刷到磁盘中，并释放内存空间。
- [History Store](https://source.wiredtiger.com/develop/arch-hs.html): 在磁盘上维护数据的历史版本信息，这些历史版本信息可能还会被使用，比如一个长耗时的事务。在 4.0 版本中也叫 Look Aside Table，4.2 之后的版本统计叫 History Store, 使用 WiredTigerHS.wt 这个特殊的表进行持久化存储。个人理解有点类似 InnoDB 中的 undo log.
- [Block Manager](https://source.wiredtiger.com/develop/arch-block.html): 内存中的 page 对应到磁盘上就是一个 block，因此 block manager 就是用来管理磁盘文件的，提供了文件的读写，extend, truncate 等接口。
- [Logging](https://source.wiredtiger.com/develop/arch-logging.html): 和 WAL(Write ahead log)、journal、redo log 等名词都是一个意思，保证了事务的持久性。在出现异常宕机时，可以通过 checkpoint + WAL 的机制将数据库恢复到最近时间的一致性状态。
- [File System & OS interface](https://source.wiredtiger.com/develop/arch-fs-os.html): 提供了跨平台（Linux/Windows 等）的文件操作接口和系统操作接口。

# 4.MongoDB 使用 WT 引擎时的数据组织

# 5. 总结

# 参考文档
1. http://source.wiredtiger.com/2.0.1/tuning.html
2. https://developer.aliyun.com/article/66848
3. https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-1
4. https://github.com/mongodb-partners/mongo-rocks

