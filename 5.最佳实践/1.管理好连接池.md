# 1. 导语
如何做好连接控制，基本上是使用网络服务都需要考虑的问题。     
在 MongoDB 场景下连接模型更为复杂。除了需要考虑 client 和 mongos 的多对多的关系，还要考虑 mongos 和 shard 之间的多对多的关系。    

如果连接太少，可能会造成请求排队超时，发挥不出 MongoDB 的整体性能。    
如果连接太多，可能会导致资源浪费，线程数太多，导致 MongoDB 性能受损。    
除了控制连接数，如何正确地利用连接超时、刷新、动态调整，都是本文要重点讨论的问题。    

# 2. 连接模型的性能问题
为什么 “连接控制” 会是一个值得讨论的话题呢？     
说到连接，首先会想到 “短连接” 的使用方式：创建一个连接，然后执行命令并返回结果，最后断开连接并结束整个使用流程。    
但是 “短连接” 模式并不是那么高效，特别是对于注重请求处理时延的场景，连接建立和断开对应 TCP 握手和挥手的多轮 RTT 延迟。如果使用了 TLS 模式，则 TLS 又会带来额外的延迟。      

对 MongoDB 而言，除了 RTT 带来的延迟问题，还有 2 个特别显著的性能问题需要关注：    

- 连接和线程的绑定关系
- 连接之后带来的认证开销

## 2.1 连接和线程
不论是 mongos 还是 mongod 进程，在完成 TCP 连接的 accept 动作之后，会创建一个线程用于服务这个 TCP 连接上的所有请求。    
具体来说，会创建一个 ServiceStateMachine 对象用来完成：接受 MongoDB 命令-> 执行命令（读写数据，过滤结果等） -> 返回执行结果给客户端 -> 接受下一个 MongoDB 命令 -> 执行下一个命令 -> 返回下一个命令的结果 -> 以此类推。     

也就是说，在 MongoDB 服务端（mongos 和 mongod），连接和线程是一一对应的。**连接的创建和断开，也会伴随着后台线程的创建和销毁。**    

## 2.2 认证开销
连接建立后，必须要在这个连接上成功执行认证流程，才能执行具体的命令。    
MongoDB 默认的认证算法是 [SCRAM-SHA-1](https://github.com/mongodb/specifications/blob/master/source/auth/auth.md#scram-sha-1) 和 [SCRAM-SHA-256](https://github.com/mongodb/specifications/blob/master/source/auth/auth.md#scram-sha-256) （高版本），都需要客户端和服务端交互 2 次，即 2 个 RTT。以 SCARM-SHA-1 为例，客户端需要顺序执行 saslStart 和 saslContinue 命令：   
```
// 逻辑流程
CMD = "n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL"
RESP = "r=fyko+d2lbbFgONRv9qkxdawLHo+Vgk7qvUOKUwuWLIWg4l/9SraGMHEE,s=rQ9ZY3MntBeuP3E1TDVC4w==,i=10000"
CMD = "c=biws,r=fyko+d2lbbFgONRv9qkxdawLHo+Vgk7qvUOKUwuWLIWg4l/9SraGMHEE,p=MC2T8BvbmWRckDw8oWl5IVghwCY="
RESP = "v=UMWeI25JD1yNYZRMpZ4VHvhZ9e0="

// 对应的命令
CMD = {saslStart: 1, mechanism: "SCRAM-SHA-1", payload: BinData(0, "biwsbj11c2VyLHI9ZnlrbytkMmxiYkZnT05Sdjlxa3hkYXdM"), options: { skipEmptyExchange: true }}
RESP = {conversationId : 1, payload: BinData(0,"cj1meWtvK2QybGJiRmdPTlJ2OXFreGRhd0xIbytWZ2s3cXZVT0tVd3VXTElXZzRsLzlTcmFHTUhFRSxzPXJROVpZM01udEJldVAzRTFURFZDNHc9PSxpPTEwMDAw"), done: false, ok: 1}
CMD = {saslContinue: 1, conversationId: 1, payload: BinData(0, "Yz1iaXdzLHI9ZnlrbytkMmxiYkZnT05Sdjlxa3hkYXdMSG8rVmdrN3F2VU9LVXd1V0xJV2c0bC85U3JhR01IRUUscD1NQzJUOEJ2Ym1XUmNrRHc4b1dsNUlWZ2h3Q1k9")}
RESP = {conversationId: 1, payload: BinData(0,"dj1VTVdlSTI1SkQxeU5ZWlJNcFo0Vkh2aFo5ZTA9"), done: true, ok: 1}
```

示意图如下：

<p align="center">
  <img src="https://github.com/pengzhenyi2015/MongoDB-Kernel-Study/assets/16788801/9a9654e3-cebd-4492-bc6e-b55a8d84429a" width=700>
</p>

除了网络交互带来的延迟问题，认证命令还会导致 MongoDB 服务端的 CPU 使用率变高。    
从上面的流程可以看到，认证过程中需要生成随机数来保证流程的安全性。MongoDB 为了保证随机数的“真随机”，会通过系统调用读取 [/dev/urandom](https://github.com/mongodb/mongo/blob/r5.0.26/src/mongo/platform/random.cpp#L160) 中的数据，消耗较多的 CPU 资源。    
如果将这里的算法调整为真随机数和伪随机数相结合的方式，能够有效缓解 CPU 消耗。    

# 3. 连接池
连接池是一个能够有效解决连接问题的方案，对 MongoDB 来说，也是如此。     
下面探讨一下使用连接池需要注意的问题：超时处理、刷新机制以及如何进行动态调整。    

## 3.1 超时


## 3.2 刷新


## 3.3 动态调整


# 4. 连接池使用方式

## 4.1 Client 到 MongoDB 

## 4.2 内部连接池：mongos 到 mongod


# 5. 客户端连接池和负载均衡


# 6. 总结


# 7. 参考资料
1. https://zhuanlan.zhihu.com/p/561776899
2. https://github.com/mongodb/specifications/blob/master/source/auth/auth

